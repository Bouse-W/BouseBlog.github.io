<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes for The seL4 Microkernel - An Introduction | BouseBlog</title>
<link rel="shortcut icon" href="https://bouse-w.github.io/BouseBlog.github.io//favicon.ico?v=1742972353564">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://bouse-w.github.io/BouseBlog.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Notes for The seL4 Microkernel - An Introduction | BouseBlog - Atom Feed" href="https://bouse-w.github.io/BouseBlog.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="å¼•ç”¨å†…å®¹å‡æ¥è‡ª seL4 overviewï¼Œéƒ¨åˆ†æ–‡æ®µå°ä¿®äº†è¯­åºä½¿å¥å­é€šé¡ºï¼Œå¼•ç”¨æ–‡æœ¬ä¸ºå±…ä¸­æ–œä½“ã€‚
å¼€æºä¸‡å²ã€‚
Chapter 2 seL4 Is a Microkernel and a Hypervisor, It Is Not an OS
..." />
    <meta name="keywords" content="System_programming" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://bouse-w.github.io/BouseBlog.github.io/">
  <img class="avatar" src="https://bouse-w.github.io/BouseBlog.github.io//images/avatar.png?v=1742972353564" alt="">
  </a>
  <h1 class="site-title">
    BouseBlog
  </h1>
  <p class="site-description">
    è®©æˆ‘ä»¬é‡æ–°å¼€å§‹
  </p>
  <div class="menu-container">
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/" class="menu">
          é¦–é¡µ
        </a>
      
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/archives" class="menu">
          å½’æ¡£
        </a>
      
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/tags" class="menu">
          æ ‡ç­¾
        </a>
      
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/post/about" class="menu">
          å…³äº
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Notes for The seL4 Microkernel - An Introduction
            </h2>
            <div class="post-info">
              <span>
                2025-03-18
              </span>
              <span>
                29 min read
              </span>
              
                <a href="https://bouse-w.github.io/BouseBlog.github.io/tag/6in0akQ6Fb/" class="post-tag">
                  # System_programming
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>å¼•ç”¨å†…å®¹å‡æ¥è‡ª <a href="https://sel4.systems/About/seL4-whitepaper.pdf"><code>seL4 overview</code></a>ï¼Œéƒ¨åˆ†æ–‡æ®µå°ä¿®äº†è¯­åºä½¿å¥å­é€šé¡ºï¼Œå¼•ç”¨æ–‡æœ¬ä¸ºå±…ä¸­æ–œä½“ã€‚<br>
å¼€æºä¸‡å²ã€‚</p>
<h5>Chapter 2 seL4 Is a Microkernel and a Hypervisor, It Is Not an OS</h5>
<h6>Monolithic kernels vs Microkernels</h6>
<blockquote>
<p><em>The monolithic OS kernel offers services such as file storage and networking to applications. All the code that implements those services executes in the privileged mode of the hardware, also called kernel mode or supervisor mode â€“ the execution mode that has unfettered access and control of all resources in the system</em>.</p>
</blockquote>
<blockquote>
<p><em>The microkernel provides almost no services: it is just a thin wrapper around hardware, just enough to securely multiplex hardware resources</em>.</p>
</blockquote>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/Operating-system-structure.png" alt="Operating-system-structure." style="zoom:60%">
	<figcaption>
	<font size=2>Different operating system structure.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 2.1</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>Linux has a large trusted computing base (TCB), which is defined as the subset of the overall system that must be trusted to operate correctly for the system to be secure</em>.</p>
</blockquote>
<blockquote>
<p><em>The idea behind a microkernel design is to drastically reduce the TCB and thus the attack surface</em>.</p>
</blockquote>
<blockquote>
<p><em>What the microkernel mostly provides is isolation, sandboxes in which programs can execute without interference from other programs. And, critically, it provides a protected procedure call mechanism, for historic reasons called IPC</em>.</p>
</blockquote>
<h6>seL4 Is a microkernel, not an OS
</h6>
<blockquote>
<p><em>seL4 is a microkernel, and designed for generality while minimising the TCB</em>.</p>
</blockquote>
<blockquote>
<p><em>Being a microkernel, seL4 contains none of the usual OS services; such services are provided by programs running in user mode</em>.</p>
</blockquote>
<blockquote>
<p><em>An important enabler is a component framework; it allows developers to focus on the code that implements the services, and automates much of the system integration. There are presently two main component frameworks for seL4, both open source: CAmkES and Genode</em>.</p>
</blockquote>
<h6>seL4 is also a hypervisor</h6>
<blockquote>
<p><em>It is possible to run virtual machines on seL4, and inside the virtual machine (VM) a mainstream OS, such as Linux</em>.</p>
</blockquote>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/Using-virtualisation.png" alt="Using-virtualisation." style="zoom:60%">
	<figcaption>
	<font size=2>seL4 as a hypervisor.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 2.3</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>When used as a hypervisor, seL4 runs in the appropriate hypervisor mode (EL2 on Arm, Root Ring-0 on x86, HS on RISC-V), which is a higher privilege level than the guest operating system</em>.</p>
</blockquote>
<h6>seL4 is not seLinux</h6>
<blockquote>
<p><em>In other words, seLinux is an add-on to a fundamentally insecure operating system and thus remains fundamentally insecure. In contrast, seL4 provides bullet-proof isolation from the ground up</em>.</p>
</blockquote>
<h5>Chapter 3 seL4â€™s Verification Story</h5>
<h6>Functional correctness</h6>
<blockquote>
<p><em>The core of seL4â€™s verification is the functional correctness proof, which says that the C implementation is free of implementation defects</em>.</p>
</blockquote>
<blockquote>
<p><em>There is a formal specification of the kernelâ€™s functionality, expressed in a mathematical language called higher-order logic</em>.</p>
</blockquote>
<blockquote>
<p><em>Everything we want to know about the kernelâ€™s behaviour (other than timing) is expressed by the abstract spec, and the kernel cannot behave in ways that are not allowed by the spec. Among others, this rules out the usual attacks against operating systems, such as stack smashing, null-pointer dereference, any code injection or control-flow highjacking etc</em>.</p>
</blockquote>
<h6>Translation validation</h6>
<blockquote>
<p><em>Those compilers (we use GCC) are themselves large, complex programs that have bugs. So we could have a bug-free kernel that gets compiled into a buggy binary</em>.</p>
</blockquote>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/translationValidationProofChain.png" alt="Translation validation proof chain." style="zoom:60%">
	<figcaption>
	<font size=2>Translation validation proof chain.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 3.2</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>The C program that is proved to refine the abstract spec, and the C program that we prove to be equivalent to the binary, are the same Isabelle/HOL formalisations</em>.</p>
</blockquote>
<h6>Secutiry properties</h6>
<blockquote>
<p><em>Specifically, seL4 enforces:<br>
<strong>confidentiality</strong>: seL4 will not allow an entity to read (or otherwise infer) data without having been explicitly given read access to the data;<br>
<strong>integrity</strong>: seL4 will not allow an entity to modify data without having been explicitly given write access to the data;<br>
<strong>availability</strong>: seL4 will not allow an entity to prevent another entityâ€™s authorised use of resources</em>.</p>
</blockquote>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/seL4ProofChain.png" alt="seL4â€™s proof chain." style="zoom:60%">
	<figcaption>
	<font size=2>seL4â€™s proof chain.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 3.1</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>These proofs presently do not capture properties associated with time</em>.</p>
</blockquote>
<h6>Proofs assumptions</h6>
<blockquote>
<p><em>All reasoning about correctness is based on assumptions, whether the reasoning is formal or informal</em>.</p>
</blockquote>
<blockquote>
<p><em>The verification of seL4 makes three assumptions:<br>
<strong>Hardware behaves as expected</strong>.<br>
<strong>The spec matches expectations</strong>. If the spec is informal or non-existent, then it is obviously impossible to precisely reason about correct behaviour. One can reduce this risk by proving properties about the spec. That then shifts the problem to the specification of those properties. They are much simpler than the kernel spec, reducing the risk of misunderstanding.<br>
<strong>The theorem prover is correct</strong>.</em></p>
</blockquote>
<h6>The CAmkES component framework</h6>
<blockquote>
<p><em>CAmkES is a component framework that allows you to reason about a system architecturally, i.e. as a collection of sandboxed components with defined communication channels</em>.</p>
</blockquote>
<p><code>CAmkES</code> æ˜¯ä¸€ä¸ªç»„ä»¶æ¡†æ¶ï¼Œå¸®åŠ©ç”¨æˆ·ä»æ¶æ„å±‚é¢æ„å»ºç³»ç»Ÿã€‚ä½¿ç”¨ <code>CAmkES</code>ï¼Œå¯ä»¥å°†ç³»ç»Ÿç»„ä»¶è§†ä½œå¸¦æœ‰é€šä¿¡ä¿¡é“çš„æ²™ç›’ï¼Œé€šè¿‡å®šä¹‰ä¸åŒçš„ç»„ä»¶ã€æ¥å£ã€è¿æ¥å™¨ï¼ˆå»ºç«‹ç»„ä»¶é—´çš„è¿æ¥ï¼‰æ¥æ„å»ºç³»ç»Ÿã€‚</p>
<blockquote>
<p><em><strong>Components</strong> are represented as square boxes. They represent programs, code and data, encapsulated by seL4.<br>
<strong>Interfaces</strong> are shown as decorations on the components. They define how a component can be invoked, or can invoke others. An interface is either imported (invoking an interface of another component) or exported (able to be invoked by another componentâ€™s imported interface), except for the shared-memory interface, which is symmetric.<br>
<strong>Connectors</strong> connect like interfaces by linking an importing with an exporting interface. Connectors in CAmkES are always one-to-one, but broadcast or multicast functionality can be implemented on top of this model by building components that copy inputs to multiple outputs</em>.</p>
</blockquote>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/CAmkES-components-and-connectors.png" alt="CAmkES components and connectors." style="zoom:60%">
	<figcaption>
	<font size=2>CAmkES components and connectors.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 3.3</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>The CAmkES system is specified in a formal architecture description language (the CAmkES ADL), which contains a precise description of the components, their interfaces and the connectors that link them up</em>.</p>
</blockquote>
<blockquote>
<p><em>The CAmkES framework contains a compiler which automatically translates CAmkES ADL into CapDL(Capability distribution language, a formal seL4-level descrtiption language)</em>. The CapDL spec is a precise representation of access rights in the system, and it is what seL4 enforces*.</p>
</blockquote>
<p>åœ¨ç”¨æˆ·å±‚ï¼Œ<code>CAmkES</code> æä¾›äº† <code>the CAmkES ADL</code> è¯­è¨€æ¥æè¿°ç»„ä»¶ã€æ¥å£ã€è¿æ¥ç­‰ï¼Œ<code>CAmkES</code> æ¡†æ¶ä¸­è‡ªå¸¦ä¸€ä¸ªç¼–è¯‘å™¨å°†ç”¨æˆ·çº§çš„ <code>ADL(Architecture Description Language)</code> è¯­è¨€æ–‡ä»¶è½¬æ¢ä¸ºç³»ç»Ÿçº§çš„ <code>CapDL(Capabilities Description Language)</code> è¯­è¨€æ–‡ä»¶ã€‚</p>
<blockquote>
<p><em>So we need assurance that the system boots up into the state described by the CapDL spec. We achieve this with a second automated step: We generate from CapDL the startup code(init.c) that, as soon as seL4 itself has booted, takes control and generates all the seL4 objects referenced by the spec, including the ones describing active components, and distributes the capabilities (see Chapter 4) that grant access to those objects according to the spec.</em></p>
</blockquote>
<p><code>seL4</code> å¼ºåˆ¶è¦æ±‚ç³»ç»ŸæŒ‰ç…§ <code>CapDL</code> æ–‡ä»¶æ‰€æè¿°çš„æ„å»ºå’Œè¿è¡Œã€‚åœ¨ <code>seL4</code> å¯åŠ¨åç«‹å³æ ¹æ® <code>CapDL</code> æ–‡ä»¶ç”Ÿæˆ <code>init.c</code> å’Œ <code>glue.c</code> ç­‰åˆå§‹åŒ–ç”¨çš„æºä»£ç æ–‡ä»¶ï¼ŒåŸºäºæ­¤è¿è¡Œç”Ÿæˆå†…å­˜å¯¹è±¡ã€åˆ†å‘æƒé™ã€å»ºç«‹ç³»ç»Ÿã€‚</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/Verified-architecture-mapping-and-system-generation.png" alt="Verified architecture mapping and system generation." style="zoom:60%">
	<figcaption>
	<font size=2>Verified architecture mapping and system generation.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 3.4</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>Sending data through a connector requires invocation of seL4 system calls, the exact details of which are hidden by the CAmkES abstraction. The glue code is setting up these system calls</em>.</p>
</blockquote>
<h5>Chapter 4 About Capabilities</h5>
<h6>What are capabilities</h6>
<blockquote>
<p><em>The capability is an encapsulation of an object reference and the rights it conveys to that object</em>.</p>
</blockquote>
<blockquote>
<p><em>In a capability-based system, such as seL4, invoking a capability is the one and only way of performing an operation on a system object.</em></p>
</blockquote>
<p><code>capability</code> æ˜¯å¯¹è±¡å¼•ç”¨å’Œè®¿é—®æƒé™çš„å°è£…ï¼Œåœ¨å…·ä½“çš„å®ç°ä¸­å¸¸è¢«å½“ä½œä¸€ä¸ªâ€œå¤§å·æŒ‡é’ˆâ€ï¼ˆ<code>fat pointer</code>ï¼‰ã€‚åœ¨ <code>seL4</code> ä¸­ï¼Œå¯¹ç³»ç»Ÿå¯¹è±¡æ‰§è¡ŒæŸäº›æ“ä½œçš„å”¯ä¸€æ–¹å¼å°±æ˜¯è°ƒç”¨ç›¸å…³çš„ <code>capability</code>ã€‚</p>
<blockquote>
<p><em>The rights given to a component can be restricted to the absolute minimum it needs to do its job, as required by the principle of least privilege(also called principle of least authority, short POLA)</em>.</p>
</blockquote>
<p>éµå¾ªâ€œæœ€å°æƒé™åŸåˆ™â€ï¼ˆ<code>POLA</code>ï¼‰æ˜¯ <code>seL4</code> ä¿è¯ç³»ç»Ÿå®‰å…¨çš„åŸºç¡€ä¹‹ä¸€ã€‚</p>
<blockquote>
<p><em>There are ten types of seL4 objects, all referenced by capabilities:<br>
<strong>Endpoints</strong> are used to perform protected function calls;<br>
<strong>Reply Objects</strong> represent a return path from a protected procedure call;<br>
<strong>Address Spaces</strong> provide the sandboxes around components (thin wrappers abstracting hardware page tables);<br>
<strong>Cnodes</strong> store capabilities representing a componentâ€™s access rights;<br>
<strong>Thread Control Blocks</strong> represent threads of execution;<br>
<strong>Scheduling Contexts</strong> represent the right to access a certain fraction of execution time on a core;<br>
<strong>Notifications</strong> are synchronisation objects (similar to semaphores);<br>
<strong>Frames</strong> represent physical memory that can be mapped into address spaces;<br>
<strong>Interrupt Objects</strong> provide access to interrupt handling;<br>
<strong>Untypeds</strong> unused (free) physical memory that can be converted (â€œretypedâ€) into any of the other types</em>.</p>
</blockquote>
<h6>Why capabilities</h6>
<blockquote>
<p><em>Capabilities provide fine-grained access control, in line with the security principle of least privilege (also called principle of least authority, short POLA). This is in contrast to the more traditional access-control model of access-control lists (ACLs)</em>.</p>
</blockquote>
<blockquote>
<p><em>With capabilities, the kernel will allow an operation to go ahead if and only if the subject that requests the operation presents a capability that empowers it to perform the operation</em>.</p>
</blockquote>
<p><code>Linux</code> æ“ä½œç³»ç»Ÿä¸­ä½¿ç”¨ <code>Access control Lists(ACLs)</code> è¿›è¡Œè®¿é—®æ§åˆ¶ï¼Œæ˜¯ä¸€ç§é¢å‘ç³»ç»Ÿèµ„æºï¼ˆ<code>subject-oriented</code>ï¼‰çš„ç²—ç²’åº¦æ§åˆ¶æ–¹å¼ã€‚<code>seL4</code> ä¸­ä½¿ç”¨çš„ <code>capability</code> æœºåˆ¶éµå¾ªæœ€å°æƒé™åŸåˆ™ï¼ˆ<code>Principle Of Least Authority</code>ï¼‰ï¼Œé¢å‘èµ„æºè®¿é—®è€…ï¼ˆ<code>object-oriented</code>ï¼‰ï¼Œå¯è¿›è¡Œç»†ç²’åº¦çš„è®¿é—®æ§åˆ¶ï¼Œåœ¨â€œé™åˆ¶åœºæ™¯â€ï¼ˆ<code>confined scenario</code>ï¼‰ä¸­æœ‰æ¯” <code>ACLs</code> æ›´å¥½çš„æ•ˆç”¨ã€‚</p>
<blockquote>
<p><em>Capabilities have  the ability to interpose access, which is a consequence of the fact that they are opaque object references</em>.</p>
</blockquote>
<blockquote>
<p><em>Interposition has applications beyond enforcing security policies; the approach can be used for packet filtering, information-flow tracing and many more. A debugger can transparently interpose and virtualise object invokations. It can even be used to create objects lazily</em>.</p>
</blockquote>
<p><code>capabilities</code> æ˜¯ä¸é€æ˜ï¼ˆå¯¹ç”¨æˆ·ï¼‰çš„å¯¹è±¡å¼•ç”¨ï¼Œå› æ­¤ <code>capability</code> æœºåˆ¶å…·æœ‰è®¿é—®ä»‹å…¥çš„èƒ½åŠ›ï¼Œå¯ä»¥ç”¨æ¥å¼ºåˆ¶ç»´æŠ¤ç³»ç»Ÿå®‰å…¨ã€å¯¹å†…æ ¸å¯¹è±¡è¿›è¡Œè®¿é—®ä»£ç†ã€ç›‘è§†ç³»ç»Ÿè°ƒç”¨ã€è¿½è¸ªå’Œè¿‡æ»¤æ•°æ®åŒ…å’Œæ•°æ®æµã€æ‡’åŠ è½½å†…å­˜å¯¹è±¡ç­‰ã€‚å…¶å®å’Œä¸­é—´äººæ”»å‡»çš„åŸç†ç±»ä¼¼ï¼Œåƒæ˜¯æ·»åŠ äº†ä¸€å±‚ä»£ç†ï¼Œåªä¸è¿‡è¿™é‡Œæ˜¯ä¸ºäº†ä¿è¯å®‰å…¨æ€§ã€‚</p>
<blockquote>
<p><em>Another advantage of capabilities is that they support safe and efficient delegation of privilege, the new capability can <strong>have diminished rights</strong> and be used <strong>without referring back to the distributer</strong>.</em></p>
</blockquote>
<p><code>capability</code> æœºåˆ¶å¯ä»¥å®‰å…¨é«˜æ•ˆåœ°åˆ†å‘ <code>capabilities</code>ï¼Œæ¥æ”¶è€…é€šå¸¸æ˜¯è·å¾—å‰Šå¼±è¿‡çš„ <code>capabilities</code>ï¼Œä½¿ç”¨è¿‡ç¨‹ä¸­å¯ä»¥ä¸å›è°ƒåŸå§‹çš„åˆ†å‘è€…ï¼Œè¿™æ ·æé«˜äº†æ•ˆç‡ã€‚</p>
<blockquote>
<p><em>A typical case of delegation's use is setting up sub-systems that manage resources autonomously</em>.</p>
</blockquote>
<blockquote>
<p><em>ACLs have an unsolvable problem, generally called the confused deputy, the fundamental problem here is that ACL-based systems use ambient authority for determining access rights: The validity of an operation is determined by the security state of the agent (compiler), which in this case is a deputy operating on behalf of an original agent (Alice).</em></p>
</blockquote>
<blockquote>
<p><em>For proper security, denomination (the reference to the file) and authority (the right to perform operations on the file) must be coupled, a principle called no designation without authority.</em></p>
</blockquote>
<blockquote>
<p><em>Next time someone is trying to sell you a â€œsecureâ€ OS, not only ask whether they have a correctness proof for the OS, but also whether it uses capability-based access control. If the answer to either questions is â€œnoâ€, then youâ€™re being offered snake oil.</em></p>
</blockquote>
<h5>Chapter 5 Support for Hard Real-Time Systems</h5>
<h6>General real-time Support</h6>
<blockquote>
<p>*seL4 has **a simple, priority-based scheduling policy *<em>that is easy to understand and analyse, a core requirement for hard real-time systems. <strong>The kernel will, on its own, never adjust priorities, so the user is in control</strong>.</em></p>
</blockquote>
<blockquote>
<p><em>Another requirement are <strong>bounded interrupt latencies</strong>.</em></p>
</blockquote>
<p>ç¡¬å®æ—¶ç³»ç»Ÿæœ‰ä¸¤é¡¹åŸºæœ¬è¦æ±‚ï¼šåŸºäºä¼˜å…ˆçº§çš„è°ƒåº¦ç­–ç•¥ã€æœ‰é™çš„ä¸­æ–­å»¶è¿Ÿï¼ŒäºŒè€…éƒ½åœ¨ <code>seL4</code> ä¸­å¾—åˆ°äº†æ»¡è¶³ã€‚</p>
<blockquote>
<p><em>seL4, like most members of the L4 microkernel family, <strong>executes with interrupts disabled while in kernel mode</strong>. This design decision greatly simplifies the kernel design and implementation, as the kernel (on a unicore processor) requires no concurrency control. seL4â€™s formal verification would otherwise be infeasible, but <strong>the design is also an enabler for excellent average-case performance</strong>.</em></p>
</blockquote>
<p><code>seL4</code> åœ¨å†…æ ¸æ€è¿è¡Œæ—¶ä¼šç¦æ­¢ä¸€åˆ‡ä¸­æ–­ï¼Œè¿™æ ·çš„è®¾è®¡æå‡äº†ä¸€èˆ¬æƒ…å†µä¸‹çš„ç³»ç»Ÿæ€§èƒ½ã€‚è€Œ <code>seL4</code> é€šå¸¸éƒ½è¿è¡Œåœ¨å•æ ¸å¤„ç†å™¨ä¸Šä¸éœ€è¦åšå¹¶å‘æ§åˆ¶ï¼Œå¦‚æ­¤è®¾è®¡è¿˜ç®€åŒ–äº†ç³»ç»Ÿå®ç°ã€‚</p>
<blockquote>
<p><em>There is a widespread belief that a real-time OS must be preemptible, except for short critical sections, in order to keep interrupt latencies low. While true for traditional unprotected RTOSes running on simple microcontrollers, this belief is mistaken for a protected-mode system, such as seL4. The reason is that when running on a powerful microprocessor with memory protection enabled, the time for entering the kernel, switching context, and exiting the kernel, is significant, and not much less than a seL4 system call. In terms of interrupt latencies, little could be gained by a preemptible design, but the cost in terms of complexity would be very high, making a preemptible design unjustified</em></p>
</blockquote>
<p>ä¸€èˆ¬çš„ <code>RTOS</code> è®¾è®¡ä¸­æœ‰ä¸€ä¸ªä¸æˆæ–‡çš„è§„å®šï¼Œå³ <code>RTOS</code> åº”å½“æ”¯æŒæŠ¢å å¼è°ƒåº¦ï¼Œä»¥æ­¤é™ä½ä¸­æ–­å“åº”çš„å»¶è¿Ÿã€‚ä½†è¿™å¯¹æ”¯æŒä¿æŠ¤æ¨¡å¼ï¼ˆ<code>protected mode</code>ï¼‰çš„ <code>RTOS</code> å¦‚ <code>seL4</code> æ¥è¯´å¹¶ä¸ä¸€å®šåˆé€‚ï¼Œå› ä¸ºå½“ç³»ç»Ÿè¿è¡Œåœ¨æä¾›å†…å­˜ä¿æŠ¤ï¼ˆ<code>memory proetction</code>ï¼‰çš„å¾®å¤„ç†å™¨ä¸Šæ—¶ï¼Œä¸ºäº†å®ç°æŠ¢å å¼è°ƒåº¦è€Œæ‰§è¡Œçš„è¿›å…¥å†…æ ¸æ€ã€åˆ‡æ¢ä¸Šä¸‹æ–‡ã€é€€å‡ºå†…æ ¸æ€ç­‰æ“ä½œéƒ½æœ‰å¾ˆå¤§çš„æ—¶é—´å¼€é”€ï¼Œæ•…è€ŒæŠ¢å å¼è®¾è®¡å¯¹é™ä½ä¸­æ–­å»¶è¿Ÿæ”¶æ•ˆç”šå¾®ï¼Œåå€’æé«˜äº†ç³»ç»Ÿå¤æ‚æ€§ã€‚</p>
<blockquote>
<p><em>This works as long as all system calls are short.</em></p>
</blockquote>
<p><code>seL4</code> ä¸æ”¯æŒæŠ¢å å¼è°ƒåº¦å´è¿˜èƒ½ä¿è¯ä¸­æ–­å»¶è¿Ÿè¾ƒä½å¾—ç›Šäºå®ƒçš„ç³»ç»Ÿè°ƒç”¨ï¼ˆ<code>system call</code>ï¼‰éƒ½æ¯”è¾ƒçŸ­å°ï¼ˆ<code>short</code>ï¼‰ã€‚</p>
<blockquote>
<p><em>Revoking a capability can be a long-running operation. seL4 deals with this situation by breaking such operations into short sub-operations, and making it possible to abort and restart the complete operation after each sub-operation, should there be a pending interrupt.</em></p>
</blockquote>
<p>å…¶å®å¹¶éæ‰€æœ‰ <code>seL4</code> ç³»ç»Ÿè°ƒç”¨éƒ½æ˜¯çŸ­å°ç²¾æ‚çš„ï¼Œæ¯”å¦‚å›æ”¶ <code>capability</code>ï¼ˆ<code>Revoking capability</code>ï¼‰ï¼Œ<code>seL4</code> çš„å¤„ç†æ–¹å¼æ˜¯æŠŠå¤§è€Œé•¿çš„ç³»ç»Ÿè°ƒç”¨åˆ†è§£æˆä¸€ç³»åˆ—çŸ­å°çš„å­æ“ä½œï¼ˆ<code>sub-operations</code>ï¼‰ï¼Œåœ¨æ¯ä¸€ä¸ªå­æ“ä½œæ‰§è¡Œå®Œæ¯•åï¼Œç³»ç»Ÿä¼šæ£€æŸ¥æ˜¯å¦æœ‰æŒ‚èµ·å¾…å¤„ç†çš„ä¸­æ–­ï¼ˆ<code>pending interrputs</code>ï¼‰ï¼Œå¦‚æœæœ‰ï¼Œæ•´ä¸ªç³»ç»Ÿè°ƒç”¨å°†è¢«ç»ˆæ­¢å¹¶ä¼ºæœºé‡å¯æ¥ä¸ºä¸­æ–­å¤„ç†è®©å‡º <code>CPU</code>ã€‚<br>
<code>seL4</code> ä½¿ç”¨äº†ä¸€ç§åä¸ºâ€œå¢é‡ä¸€è‡´æ€§â€ï¼ˆ<code>Increment Consistency</code>ï¼‰çš„æ–¹æ³•ï¼Œä½¿å¾—ç³»ç»Ÿè°ƒç”¨çš„åˆ†å‰²å’Œå­æ“ä½œçš„æ‰§è¡Œéƒ½æ˜¯ç»“æ„åŒ–çš„ï¼Œæ•´ä¸ªç³»ç»Ÿè°ƒç”¨å¯ä»¥åœ¨ä¸é‡å¤å·²ç»å®Œæˆçš„å­æ“ä½œçš„å‰æä¸‹é‡å¯</p>
<blockquote>
<p><em>We performed a complete and sound worst-case execution time (WCET) analysis of seL4, which is the only one documented for a protected-mode OS [Blackham et al., 2011, Sewell et al., 2016]. It means that we had obtained provable, hard upper bounds for all system-call latencies and, by implication, worst-case interrupt latencies.</em></p>
</blockquote>
<p>å¼€å‘è€…ä¸º <code>seL4</code> åšäº†å®Œæ•´è€Œå¯é çš„æœ€åæƒ…å†µä¸‹æ‰§è¡Œæ—¶é—´åˆ†æï¼ˆ<code>Worst Case Execution Time analysis</code>ï¼‰ï¼Œæ®æ­¤è·å¾—äº†æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨å»¶è¿Ÿçš„å¯è¯ç¡¬ä¸Šé™ï¼ˆ<code>provable, hard upper bounds</code>ï¼‰ï¼Œå¹¶æ¨å¯¼å‡ºäº†æœ€åæƒ…å†µä¸‹çš„ä¸­æ–­å»¶è¿Ÿã€‚</p>
<blockquote>
<p><em>We did the WCET analysis of seL4 for Arm v6 processors. It has since fallen into abeyance, as Arm has stopped providing the required information on the worst-case latencies of instructions, and Intel never provided those for their architecture.</em></p>
</blockquote>
<p>åœ¨æ„‰å¿«è¿›è¡Œ <code>WCET</code> çš„è¿‡ç¨‹ä¸­ï¼Œ<code>Arm</code> çªç„¶å˜å¦ï¼Œæˆ‘è§‰å¾—ä¸å…¶è¿™æ ·ä¸å¦‚å­¦ <code>Intel</code> ä¸€è·¯é—­æºåˆ°åº•ï¼ˆï¼Œæ²¡ä»€ä¹ˆï¼Œæ·»ä¸€ç¬‘å°”ã€‚</p>
<h6>Mixed-criticality systems</h6>
<blockquote>
<p><em>Criticality is a term from the safety domain relating to the seriousness of a failure of a component. The more critical a component, the more extensive (and expensive) is the required assurance, so there is a strong incentive for keeping criticalities low.</em></p>
</blockquote>
<p>â€œå…³é”®æ€§â€æ˜¯å®‰å…¨é¢†åŸŸä¸­å’Œç»„ä»¶é”™è¯¯ä¸¥é‡æ€§ç›¸å…³çš„ä¸€ä¸ªæœ¯è¯­ã€‚ç»„ä»¶çš„å…³é”®æ€§è¶Šé«˜ï¼Œå¯¹å…¶å¯é æ€§çš„è¦æ±‚å°±è¶Šå®½æ³›ï¼Œï¼ˆå‡ºé”™ä»£ä»·ï¼‰ä¹Ÿè¶Šæ˜‚è´µï¼Œæ‰€ä»¥ç³»ç»Ÿè®¾è®¡ä¸­é™ä½ç»„ä»¶å…³é”®æ€§çš„åŠ¨æœºæ˜¯å¾ˆå¼ºçƒˆçš„ã€‚ï¼ˆåŸè°…æˆ‘è¿™å¯æ¶çš„ç›´è¯‘æ°´å¹³ğŸ’©ï¼‰</p>
<blockquote>
<p><em>A mixed-criticality system (MCS) is made up of (interacting) components of different<br>
criticalities.</em></p>
</blockquote>
<p>æ··åˆå…³é”®ç³»ç»Ÿï¼ˆ<code>MSC</code>ï¼‰æ˜¯ç”±å…³é”®æ€§ä¸åŒçš„äº¤äº’ç»„ä»¶æ„æˆçš„ã€‚å°±åƒä¸‹é¢æ‰€ç¤ºçš„ä¸€ä¸ªè‡ªåŠ¨é©¾é©¶ç³»ç»Ÿçš„ç®€å•ç¤ºæ„å›¾ï¼Œå®ƒæœ‰ä¸»æ§ç³»ç»Ÿã€ç½‘ç»œé©±åŠ¨ä¸¤ä¸ªå…³é”®ç»„ä»¶ï¼Œä¸¤ä¸ªç»„ä»¶é—´ä¼šè¿›è¡Œäº¤äº’ä»¥å…±äº«æ•°æ®ã€‚</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/Simplified-example-of-a-mixed-criticality-system.png" alt="Simplified example of a mixed criticality system" style="zoom:70%">
	<figcaption>
	<font size=2>Simplified example of a mixed criticality system.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 5.1</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>MCS's core safety requirement is that failure of a component must not affect<br>
any more critical components, so the critical components can be assured independent<br>
of the less critical ones.</em></p>
</blockquote>
<p><code>MSC</code> å®‰å…¨æ€§çš„æ ¸å¿ƒè¦æ±‚æ˜¯ï¼šä¸€ä¸ªç»„ä»¶çš„é”™è¯¯ä¸èƒ½å½±å“å…¶ä»–å…³é”®æ€§æ›´é«˜çš„ç»„ä»¶ï¼Œå› æ­¤å…³é”®ç»„ä»¶åº”å½“ç‹¬ç«‹äºæ¯”å®ƒå…³é”®æ€§ä½çš„ç»„ä»¶ã€‚</p>
<blockquote>
<p><em><strong>The trend to MCS results from the desire to consolidate</strong>: Traditionally, critical systems would use a dedicated microcontroller for each function, i.e. isolation by air-gapping. With growing functionality, this approach leads to a proliferation of processors (and their packaging and wiring), which causes space, weight and power (SWaP) problems, which MCS aim to overcome. <strong>This is similar to the security notion of having trusted and untrusted components in the same system, and the core requirement on the OS is in both cases strong isolation</strong>.</em></p>
</blockquote>
<p><code>MSC</code> ç³»ç»Ÿçš„å…´èµ·æºäºå¯¹ä¼ ç»Ÿå…³é”®æ€§ç³»ç»Ÿè¿›è¡Œæ¶æ„æ•´åˆçš„éœ€è¦ï¼Œä¼ ç»Ÿçš„å…³é”®æ€§ç³»ç»Ÿä¼šä¸ºæ¯ä¸ªåŠŸèƒ½æ¨¡å—æä¾›ä¸“ç”¨çš„å¾®æ§åˆ¶å™¨ï¼Œéšç€ç³»ç»ŸåŠŸèƒ½çš„å¢åŠ ï¼Œå¤„ç†å™¨æ•°é‡ä¹Ÿä¸æ–­å¢åŠ ï¼Œéšä¹‹è€Œæ¥çš„æ˜¯ç©ºé—´å ç”¨ã€é‡é‡å’ŒåŠŸè€—æŒç»­å¢åŠ çš„é—®é¢˜(<code>SWaP Problem</code>)ï¼Œ<code>MCS</code> å°±æ˜¯ä¸ºå…‹æœè¿™äº›é—®é¢˜è€Œæå‡ºçš„ã€‚è¿™å’Œå®‰å…¨é¢†åŸŸä¸­è¦æŠŠå—ä¿¡å’Œä¸å—ä¿¡çš„ç»„ä»¶ç»´æŒåœ¨ä¸€ä¸ªç³»ç»Ÿä¸­çš„é—®é¢˜æ˜¯ç›¸ä¼¼çš„ï¼ŒäºŒè€…çš„æ ¸å¿ƒéœ€æ±‚éƒ½æ˜¯ <code>OS</code> è¦æä¾›å¾ˆå¼ºçš„éš”ç¦»æ€§ã€‚</p>
<blockquote>
<p><em><strong>Traditional MCS OSes completely isolate components temporally and spatially</strong>, an approach called strict time and space partitioning (TSP).</em></p>
</blockquote>
<p>ä¼ ç»Ÿçš„ <code>MCS</code> æ“ä½œç³»ç»Ÿä¼šå°†ä¸åŒç»„ä»¶åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šå®Œå…¨éš”ç¦»ï¼Œè¿™è¢«ç§°ä½œâ€œä¸¥æ ¼æ—¶ç©ºé—´åˆ’åˆ†â€ï¼ˆ<code>TSP</code>ï¼‰ã€‚</p>
<blockquote>
<p><em>The TSP approach guarantees isolation, but has severe drawbacks. The most obvious one is poor resource utilisation. Another big drawback of TSP is that interrupt latencies are inherently high.</em></p>
</blockquote>
<p><code>TSP</code> æ–¹æ³•ä¿è¯äº†éš”ç¦»æ€§ï¼Œä½†æœ‰ä¸¥é‡çš„ä¸è¶³ï¼Œæœ€æ˜æ˜¾çš„å°±æ˜¯èµ„æºåˆ©ç”¨ç‡å¾ˆä½å’Œä¸­æ–­å»¶è¿Ÿè¿‡é«˜ã€‚</p>
<blockquote>
<p><em>In terms of space resources, seL4 already has a flexible, powerful and provably secure model: object capabilities. MCS support extends this to time: access to the processor is now also controlled by capabilities.</em></p>
</blockquote>
<p>è¯´èµ·ç©ºé—´èµ„æºçš„åˆ’åˆ†å’Œåˆ©ç”¨ï¼Œ<code>seL4</code> å·²ç»æœ‰äº†ä¸€ä¸ªçµæ´»ã€å¼ºå¤§å¹¶ä¸”å®‰å…¨æ€§å¯è¯çš„æ¨¡å‹ï¼š<code>object capailities</code>ã€‚æ”¯æŒ <code>MCS</code> çš„ <code>seL4</code> å°† <code>capability</code> æœºåˆ¶æ‰©å±•åˆ°äº†æ—¶é—´åŸŸä¸Šï¼šç»„ä»¶å¯¹å¤„ç†å™¨çš„å ç”¨ä¹Ÿç”± <code>capabilities</code> æ§åˆ¶ã€‚</p>
<blockquote>
<p><em>seL4â€™s capabilities for processor time are called scheduling-context capabilities. A component can only obtain processor time if it holds such a capability, and the amount of processor time it can use is encoded in the capability.</em></p>
</blockquote>
<p><code>seL4</code> ç”¨ä»¥æ§åˆ¶å¤„ç†å™¨æ—¶é—´çš„ <code>capabilities</code> å«åšä¸Šä¸‹æ–‡è°ƒåº¦ <code>capabilities</code>ï¼ˆ<code>scheduling-context capabilities</code>ï¼‰ã€‚ç»„ä»¶ä»…åœ¨æŒæœ‰ç›¸å…³ <code>capability</code> çš„æ—¶å€™æ‰èƒ½è·å–ä¸€å®šçš„å¤„ç†å™¨ä½¿ç”¨æ—¶é—´ï¼Œå…·ä½“çš„æ—¶é—´å¤šå°‘è¢«å°è£…åœ¨ <code>capability</code> ä¸­ã€‚</p>
<blockquote>
<p><em>In traditional seL4 (as in most L4 kernels before it) a thread had <strong>two main scheduling parameters: a priority and a time slice</strong>, which determine access to the processor.</em></p>
</blockquote>
<p>ä¼ ç»Ÿçš„ <code>seL4</code> ä¾æ®ä¸¤ä¸ªå‚æ•°è¿›è¡Œçº¿ç¨‹è°ƒåº¦ï¼šä¼˜å…ˆçº§ï¼ˆ<code>priority</code>ï¼‰å’Œæ—¶é—´ç‰‡ï¼ˆ<code>time slice</code>ï¼‰ã€‚</p>
<blockquote>
<p><em><strong>The MCS version of seL4 replaces the time slice by a capability to a scheduling context object</strong>, which performs a similar function, but in a more precise way that is the key to isolation: A scheduling context contains two main attributes. <strong>(1) a time budget, which is similar to the old time slice</strong>, and limits the time for which a thread can execute until preempted. <strong>(2) a time period, which determines how often the budget can be used</strong>: the thread will not get more time than one budget per period, preventing it from monopolising the CPU irrespective of its priority.</em></p>
</blockquote>
<p>æ”¯æŒ <code>MCS</code> çš„ <code>seL4</code> ç”¨ä¸Šä¸‹æ–‡è°ƒåº¦å¯¹è±¡ï¼ˆ<code>scheduling context object</code>ï¼‰ æ›¿æ¢äº†æ—¶é—´ç‰‡ï¼Œå®ç°äº†æ›´ä¸ºç²¾ç»†çš„è°ƒåº¦ï¼Œè€Œè¿™ä¹Ÿæ˜¯ä¿è¯éš”ç¦»æ€§ï¼ˆ<code>isolation</code>ï¼‰çš„å…³é”®ã€‚ä¸€ä¸ªä¸Šä¸‹æ–‡è°ƒåº¦å¯¹è±¡æœ‰ä¸¤ä¸ªå±æ€§ï¼šæ—¶é—´é¢„ç®—ï¼ˆ<code>time budget</code>ï¼‰ï¼Œå…¶ä½œç”¨å’Œæ—¶é—´ç‰‡ä¸€è‡´ã€æ—¶é—´é¢‘ç‡ï¼ˆ<code>time period</code>ï¼‰ï¼Œå†³å®šäº†çº¿ç¨‹å¯ä»¥è·å¾—æ—¶é—´é¢„ç®—çš„é¢‘ç‡ï¼Œé˜²æ­¢é«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹ä¸€ç›´å ç”¨ <code>CPU</code>ã€‚</p>
<blockquote>
<p><em><strong>Scheduling contexts support reasoning about the amount of time a thread can consume</strong>, and therefore, how much time is left.</em></p>
</blockquote>
<p>ä¸Šä¸‹æ–‡è°ƒåº¦å¯¹è±¡æ”¯æŒå¯¹çº¿ç¨‹å®é™…å¯ä»¥æ¶ˆè€—çš„ <code>CPU</code> æ—¶é—´è¿›è¡Œæ¨ç®—ï¼Œå› æ­¤ä¹Ÿè¾ƒæ˜“æ¨çŸ¥çº¿ç¨‹å®é™…å‰©ä½™çš„ <code>CPU</code> æ—¶é—´ã€‚</p>
<blockquote>
<p><em>Applied to the above example, this means that we can give the (less critical) device driver a higher priority than the (critical) control component. This allows the driver to preempt the control, leading to high responsiveness. But the budget limit will stop the driver from monopolising the CPU</em>.</p>
</blockquote>
<p>ä¸Šé¢é‚£ä¸ªè‡ªåŠ¨é©¾é©¶ç³»ç»Ÿä¸­ï¼Œå¯ä»¥èµ‹äºˆé‡è¦æ€§æ›´ä½çš„è®¾å¤‡é©±åŠ¨ä»¥æ›´é«˜çš„ä¼˜å…ˆçº§ï¼ˆé«˜äºæ§åˆ¶ç»„ä»¶ï¼‰ï¼Œè¿™æ ·å¿…è¦çš„æ—¶å€™è®¾å¤‡é©±åŠ¨å°±å¯ä»¥æŠ¢å  <code>CPU</code> ä¿è¯åŠæ—¶å“åº”ï¼ˆç›¸å½“äºé™ä½ä¸­æ–­å»¶è¿Ÿï¼‰ï¼Œä½†æ—¶é—´é¢„ç®—ï¼ˆ<code>time budget</code>ï¼‰å’Œæ—¶é—´é¢‘ç‡ï¼ˆ<code>time period</code>ï¼‰çš„é™åˆ¶ä¼šé˜»æ­¢é©±åŠ¨ä¸€ç›´å ç”¨ <code>CPU</code>ã€‚</p>
<blockquote>
<p><em>By guaranteeing the critical deadline irrespective of the behaviour of the driver, we isolate the control from the untrusted driver, according to the core requirement of MCS</em>.</p>
</blockquote>
<p>è¿˜æ˜¯ä¸Šå›¾é‚£ä¸ªè‡ªåŠ¨é©¾é©¶ç³»ç»Ÿçš„ä¾‹å­ï¼Œä½¿ç”¨ä¸Šä¸‹æ–‡è°ƒåº¦å¯¹è±¡ä¸¥æ ¼é™åˆ¶è®¾å¤‡é©±åŠ¨ï¼ˆ<code>driver</code>ï¼‰å¯¹ <code>CPU</code> çš„å ç”¨ï¼ˆä¸å—é©±åŠ¨ç»„ä»¶ä¼˜å…ˆçº§çš„å½±å“ï¼‰ï¼Œå¯ä»¥å°†æ§åˆ¶ç»„ä»¶å’Œé©±åŠ¨ç»„ä»¶å¾ˆå¥½åœ°éš”ç¦»å¼€æ¥ï¼Œæ»¡è¶³äº† <code>MCS</code> çš„æ ¸å¿ƒéœ€æ±‚ã€‚</p>
<h5>Chapter 6 Security is No Excuse for Poor Perfomance</h5>
<blockquote>
<p><em>seL4 beats the performance of any other microkernel. This is a claim that is difficult to prove, as the competition generally holds their performance data close to their chest (for very good reason!) However, we make this performance claim, publicly, at every opportunity. If anyone disagrees they need to present evidence.</em></p>
</blockquote>
<p>è‡ªè¯æ˜¯è¡¨è¾¾è€…çš„å®¿å‘½ã€‚</p>
<h5>Chpter 7 Real-World Deployment and Incremental Cyber Retrofit</h5>
<h6>General considerations</h6>
<blockquote>
<p><em>When planning to protect the security or safety of your system with seL4, the first step should be to identify the critical assets you need to protect. The aim should be to minimise this part of your trusted computing base, and make it as modular as feasible, with each module becoming an seL4-protected CAmkES component.</em></p>
</blockquote>
<blockquote>
<p><em>The other important preparation is to check availability and verification status of seL4 on your platform.</em></p>
</blockquote>
<blockquote>
<p><em>You furthermore will need to assess whether the available user-level infrastructure is<br>
sufficient for your purpose. If not, then this is where the community may help you.</em></p>
</blockquote>
<p>å½“å°è¯•ä½¿ç”¨ <code>seL4</code> ç»´æŠ¤ç³»ç»Ÿå®‰å…¨æ—¶ï¼Œåº”æå‰åšå¥½ä¸‰ç‚¹å‡†å¤‡ï¼šæ˜ç¡®éœ€è¦ä¿æŠ¤çš„å…³é”®èµ„æºï¼Œæœ€å°åŒ–å¯ä¿¡è®¡ç®—åŸºï¼ˆ<code>TCB</code>ï¼‰å¹¶å°½å¯èƒ½åœ°å°†å…¶æ¨¡å—åŒ–ä»¥ä¾¿è½¬æ¢ä¸º <code>CAmkES</code> ç»„ä»¶ã€ç¡®è®¤æ‰€ä½¿ç”¨çš„ç¡¬ä»¶å¹³å°å¯¹ <code>seL4</code> çš„éªŒè¯å’Œæ”¯æŒæƒ…å†µã€è¯„ä¼°ç°æœ‰çš„ç”¨æˆ·çº§æ¡†æ¶å’Œåº”ç”¨èƒ½å¦æ»¡è¶³å®é™…éœ€æ±‚ï¼Œè‹¥ä¸èƒ½ï¼Œå¯ä»¥å‘ç¤¾åŒºå¯»æ±‚å¸®åŠ©ã€‚</p>
<h6>Retrofitting existing systems</h6>
<blockquote>
<p><em>Most real-world deployments of seL4 will not run everything native. Typically, there are significant legacy components that would be expensive to port, because they are too big or rely on too many system services that are not presently supported by seL4. Also, frequently there would be little security or safety gain from running such legacy stacks natively.<strong>Using seL4â€™s virtualisation capabilities is frequently the pragmatic way to proceed</strong>.</em></p>
</blockquote>
<p>å½“ä¸‹å¤šæ•°å·²ç»éƒ¨ç½²çš„ <code>seL4</code> ä¸ä¼šé€‰æ‹©åœ¨åŸç”Ÿç¯å¢ƒï¼ˆ<code>native enviroment</code>ï¼‰ä¸­è¿è¡Œä¸€åˆ‡å†…å®¹ï¼ˆè®¾å¤‡é©±åŠ¨ã€ç³»ç»Ÿçº§åº”ç”¨ã€ç”¨æˆ·çº§åº”ç”¨ç­‰ï¼‰ï¼Œæˆ–æ˜¯å› ä¸ºç»„ä»¶æœ¬èº«è¿‡äºå¤æ‚åºå¤§éš¾ä»¥ç§»æ¤ï¼Œæˆ–æ˜¯å› ä¸º <code>seL4</code> ä¸èƒ½æ”¯æŒç»„ä»¶æ‰€ä¾èµ–çš„ä¸€äº›ç³»ç»Ÿè°ƒç”¨ï¼Œæˆ–æ˜¯å› ä¸ºè¿™äº›ç»„ä»¶ä»£ç è‡ªèº«çš„å®‰å…¨æ€§éš¾ä»¥ä¿è¯æ‰€ä»¥ä¸é€‚åˆ <code>running natively</code>ã€‚ä½¿ç”¨ <code>seL4</code> çš„è™šæ‹ŸåŒ–åŠŸèƒ½ï¼ˆ<code>vitrualisation capablities</code>ï¼‰æ˜¯è§£å†³è¿™äº›é—®é¢˜çš„å®ç”¨åŠæ³•ã€‚</p>
<blockquote>
<p><em>The typical approach is what we call incremental cyber-retrofit, a term coined by then DARPA program director John Launchbury.</em></p>
</blockquote>
<p>ä½¿ç”¨ <code>seL4</code> æ”¹è£…ç°æœ‰ç³»ç»Ÿæ„é€ å®‰å…¨çš„è¿è¡Œç¯å¢ƒæ—¶ï¼Œé€šå¸¸çš„æ–¹æ³•æ˜¯è¿›è¡Œâ€œå¢é‡ç½‘ç»œæ”¹é€ â€ï¼ˆ<code>incremental cyber-retrofit</code>ï¼‰ã€‚ä¸‹å›¾æ‰€ç¤ºæ˜¯ <code>HACMS</code> é¡¹ç›®æˆå‘˜ä½¿ç”¨ <code>seL4</code> å¯¹æ³¢éŸ³ <code>ULB</code> è‡ªä¸»ç›´å‡æœºé¡¹ç›®è¿›è¡Œå¢é‡ç½‘ç»œæ”¹é€ çš„å¤§è‡´è¿‡ç¨‹ã€‚</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/2024/2/Incremental-cyber-retrofit.png" alt="Incremental cyber-retrofit" style="zoom:70%">
	<figcaption>
	<font size=2>Incremental cyber-retrofit.<cite><a href="https://sel4.systems/About/seL4-whitepaper.pdf">seL4-whitepaper.Figure 7.1</a></cite></font>
  </figcaption>
</div>
<blockquote>
<p><em>The incremental cyber-retrofit typically <strong>starts out</strong> by simply putting the whole existing software stack into a virtual machine running on seL4, this step provides a baseline from where to start modularising.<br>
<strong>The next step</strong> broke out two components: The particularly untrusted camera software was moved to a second VM, also running Linux, with the two Linux VMs communicating via CAmkES channels. At the same time, the network stack was pulled out of the VM and converted to a native CAmkES component, also communicating with the main VM.<br>
<strong>The final</strong> step pulled all other critical modules, as well as the (untrusted) GPS software, into separate CAmkES components, removing the original main VM. The final system consisted of a number of CAmkES components running seL4-native code, and a single VM running just Linux and the camera software.</em></p>
</blockquote>
<p>ç»“åˆä¸Šé¢çš„å›¾ç¤ºï¼Œè¿™ä¸ªé¡¹ç›®ä¸­è¿›è¡Œ <code>incremental cyber-retrofit</code> çš„å¤§è‡´è¿‡ç¨‹æ˜¯ï¼š<br>
<strong>é¦–å…ˆ</strong>å°†æ•´ä¸ªå·²å­˜åœ¨çš„è½¯ä»¶è¿è¡Œæ ˆæ”¾åˆ°ä¸€ä¸ªåœ¨ <code>seL4</code> ä¸Šè¿è¡Œçš„è™šæ‹Ÿæœºä¸­ï¼Œå’Œ <code>seL4</code> ä¸€èµ·ä½œä¸ºåˆå§‹çš„ <code>TCB</code>ã€‚<br>
<strong>å…¶æ¬¡</strong>å°†ä¸€äº›ä¸å¯ä¿¡çš„ã€ä¾èµ–ä¸»æµæ“ä½œç³»ç»Ÿè€Œæ— æ³•è½¬åŒ–ä¸º <code>CAmkES</code> ç»„ä»¶çš„ç”¨æˆ·çº§åº”ç”¨ä» <code>TCB</code> ä¸­æ‹†å‡ºæ”¾åˆ°å…¶ä»–è™šæ‹Ÿæœºä¸­è¿è¡Œï¼ˆè™šæ‹Ÿæœºä¹‹é—´é€šè¿‡ <code>CAmkES</code> æä¾›çš„ä¿¡é“ï¼ˆ<code>channels</code>ï¼‰é€šä¿¡ï¼‰ï¼ŒåŒæ—¶å°†å¯ä»¥è½¬åŒ–ä¸º <code>CAmkES</code> ç»„ä»¶çš„é©±åŠ¨ç¨‹åºè½¬æ¢ä¸ºè¿è¡Œåœ¨ <code>seL4</code> åŸç”Ÿç¯å¢ƒä¸Šçš„ <code>CAmkES</code> ç»„ä»¶ã€‚<br>
<strong>æœ€å</strong>å°†ä¸€äº›å¯è½¬æ¢çš„é‡è¦æ¨¡å—ï¼ˆå¦‚æœ¬ä¾‹ä¸­çš„ <code>GPS module</code>ï¼‰è½¬æ¢ä¸ºç‹¬ç«‹çš„ <code>CAmkES</code> ç»„ä»¶å¹¶ä» <code>TCB</code> ä¸­æ‹†å‡ºæ”¾åˆ° <code>seL4</code> åŸç”Ÿç¯å¢ƒä¸Šè¿è¡Œï¼Œä¹‹åå°±å¯ä»¥åˆ é™¤ <code>TCB</code> ä¸­çš„è™šæ‹Ÿæœºå’ŒåŸæœ¬ä¸ºä¸€å¹²åº”ç”¨æä¾›ç³»ç»ŸæœåŠ¡çš„ <code>Linux</code></p>
<h5>Chapter 8 Conclusions</h5>
<blockquote>
<p><em>Our ongoing research aims to ensure that seL4 will retain its position as the clear leader among security- and safety-oriented OSes, for example by pioneering systematic and principled prevention of information leakage through timing channels.</em></p>
</blockquote>
<p><code>seL4</code> æœªæ¥çš„ç ”ç©¶æ–¹å‘ä¼šåŒ…æ‹¬å¼€åˆ›ä¸€ç§ç³»ç»Ÿæ€§ã€åŸåˆ™æ€§çš„æ–¹æ³•ç”¨äºé˜²æ­¢ä¿¡æ¯ä»æ—¶é—´é€šé“ï¼Ÿï¼ˆ<code>timing channels</code>ï¼‰æ³„éœ²ã€‚</p>
<blockquote>
<p><em>Besides this technological leadership, seL4 is in practical terms still far ahead of its successors: While we designed seL4 for real-world use from the beginning, almost all other verified OS kernels are academic toys, and far from real-world capable.</em></p>
</blockquote>
<p>çœ‹å¾—å‡ºæ¥ <code>seL4</code> çš„è€å“¥ä»¬å¯¹ä»–ä»¬çš„ä½œå“æ˜¯ç›¸å½“éª„å‚²äº†ğŸ¤£</p>
<blockquote>
<p><em>seL4â€™s real-world readiness is a result of two aspects that drove the design: uncompromising performance focus, as highlighted in Chapter 6, and mechanisms that are designed to support the widest range of application scenarios and security policies, the latter enabled by capability-based access control.</em></p>
</blockquote>
<p><code>seL4</code> åœ¨ç”Ÿäº§å®è·µä¸­è‰¯å¥½çš„é€‚ç”¨æ€§ï¼ˆè€Œä¸æ˜¯æˆä¸ºä¸€ä¸ª <code>academic toy</code>ï¼‰å¾—ç›Šäºä¸¤ä¸ªæ–¹é¢çš„è®¾è®¡ç†å¿µï¼Œä¸€æ˜¯å¯¹ç³»ç»Ÿæ€§èƒ½çš„åšæŒï¼ŒäºŒæ˜¯ä¸ºäº†æ”¯æŒæœ€å¹¿æ³›çš„åº”ç”¨åœºæ™¯å’Œå®‰å…¨ç­–ç•¥è€Œåˆ¶å®šçš„è¿è¡Œæœºåˆ¶ï¼Œä¹Ÿå°±æ˜¯åŸºäº <code>capability</code> çš„è®¿é—®æ§åˆ¶ã€‚</p>
<p>åˆ°è¿™é‡Œè¿™ä¸ªç‰ˆæœ¬çš„ <code>seL4 white paper</code> ç®—æ˜¯ç»“æŸäº†ï¼Œå¸Œæœ›æœ‰æœä¸€æ—¥çœ‹åˆ°è€å“¥ä»¬æ›´æ–°å…³äºæå‡ <code>timing channels</code> å®‰å…¨æ€§çš„å†…å®¹ã€‚</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">ä¸‹ä¸€ç¯‡</div>
            <a href="https://bouse-w.github.io/BouseBlog.github.io/post/notes-for-makefile-in-nvboard-examples/">
              <h3 class="post-title">
                Notes for Makefile in nvboard examples
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  <p><font size=1>åŸåšå®¢ç½‘ç«™ rerevolution.cnï¼ˆæœåŠ¡å™¨è¿‡æœŸäº†ï¼‰çš„é‡å»º</font></p>
  <a class="rss" href="https://bouse-w.github.io/BouseBlog.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
