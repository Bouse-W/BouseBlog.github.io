<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>seL4_Fault handling | BouseBlog</title>
<link rel="shortcut icon" href="https://bouse-w.github.io/BouseBlog.github.io//favicon.ico?v=1742972353564">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://bouse-w.github.io/BouseBlog.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="seL4_Fault handling | BouseBlog - Atom Feed" href="https://bouse-w.github.io/BouseBlog.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Author: Bouse-w
引用内容若无明确标注，则直接或间接来自 seL4 Docs/Tutorials/Fault
部分文段做了微小增删使句子通顺。
Background: What is a fault, and what is ..." />
    <meta name="keywords" content="seL4" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://bouse-w.github.io/BouseBlog.github.io/">
  <img class="avatar" src="https://bouse-w.github.io/BouseBlog.github.io//images/avatar.png?v=1742972353564" alt="">
  </a>
  <h1 class="site-title">
    BouseBlog
  </h1>
  <p class="site-description">
    让我们重新开始
  </p>
  <div class="menu-container">
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/" class="menu">
          首页
        </a>
      
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://bouse-w.github.io/BouseBlog.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              seL4_Fault handling
            </h2>
            <div class="post-info">
              <span>
                2025-03-18
              </span>
              <span>
                8 min read
              </span>
              
                <a href="https://bouse-w.github.io/BouseBlog.github.io/tag/6eXd77a8Oo/" class="post-tag">
                  # seL4
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>Author: Bouse-w</p>
<p>引用内容若无明确标注，则直接或间接来自 <a href="https://docs.sel4.systems/Tutorials/fault-handlers"><code>seL4</code> Docs/Tutorials/Fault</a><br>
部分文段做了微小增删使句子通顺。</p>
<h2 id="background-what-is-a-fault-and-what-is-a-fault-handler">Background: What is a fault, and what is a fault handler?</h2>
<blockquote>
<p>In seL4, faults are modeled as separately programmer-designated “fault handler” threads. In monolithic kernels, faults are not usually delivered to a userspace handler, but they are handled by the monolithic kernel itself.</p>
</blockquote>
<p><code>seL4</code> 中错误处理函数由程序员编写和指定，在用户态运行一个错误处理线程。对比而言，宏内核中的错误都由内核处理。</p>
<h2 id="thread-faults-vs-other-sources-of-faults">Thread faults vs other sources of faults</h2>
<blockquote>
<p>There are several sources of faults in a running system; they include:</p>
<ul>
<li>Fault events generated by the CPU itself when it encounters anomalies in the instruction stream (aka, “processor exceptions”).</li>
<li>Fault events generated by hardware in the event of some hardware anomaly (such as a machine check or non-maskable interrupt).</li>
<li>Fault events generated by the seL4 kernel when it encounters anomalies in the current thread.</li>
</ul>
</blockquote>
<p>错误来源主要有：<code>CPU</code> 执行指令出错，其它硬件出错，当前进程遇到异常情况使 <code>seL4</code> 内核出错。</p>
<h2 id="how-does-thread-fault-handling-work">How does thread fault handling work?</h2>
<blockquote>
<p>In seL4, when a thread generates a thread fault, the kernel will <strong>block</strong> the faulting thread’s execution and attempt to deliver a message across a special endpoint associated with that thread, called its <strong>“fault handler” endpoint</strong>.</p>
<p>The only special thing about the fault handler endpoint is that a thread can only have <em>one</em> of them.</p>
</blockquote>
<p><code>seL4</code> 中，发生进程错误时，内核阻塞出错进程，并尝试向出错进程的 <code>fault handler endpoint</code> 发送一条消息。</p>
<p>每个进程只能拥有一个 <code>fault handler endpoint</code>，即此对象不可复制。</p>
<blockquote>
<p>The thread which is listening on the other end of the fault endpoint is called the <strong>“fault handler”</strong>.</p>
<p>The kernel expects that the fault handler will correct the anomaly that ails the faulting thread and then tell the kernel when it is safe to try executing the faulting thread once again.</p>
</blockquote>
<p><code>fault handler endpoint</code> 另一端连接的错误消息接收进程即 <code>fault handler</code>。</p>
<p>内核希望 <code>fault handler</code> 能修正错误，并告诉内核可以在何时恢复执行出错进程。</p>
<blockquote>
<p>To tell the kernel to resume execution of the faulting thread, the fault handler can either:</p>
<ul>
<li>Invoke a reply operation (with <code>seL4_Reply()</code>) on the fault handler endpoint and make sure that the <code>label</code> in the <code>seL4_MessageInfo_t</code> tag is set to <code>0</code>;</li>
<li>Explicitly tell the kernel to resume executing the faulting thread using <code>seL4_TCB_Resume()</code>.</li>
</ul>
</blockquote>
<p><code>fault handler</code> 有两种方式通知内核可以恢复执行出错进程：</p>
<ol>
<li>对 <code>fault handler endpoint</code> 调用 <code>seL4_Reply</code>，但必须保证将消息信息结构体（<code>seL4_MessageInfo_t</code>）中的 <code>label</code> 域置为 <code>0</code>。</li>
<li>调用 <code>seL4_TCB_Resume()</code> 显式通知内核可以恢复执行出错进程了。</li>
</ol>
<blockquote>
<p>If the fault handler did not properly rectify the anomaly in the faulting thread, resuming the faulting thread will simply cause the kernel to re-generate the fault.</p>
</blockquote>
<p>如果 <code>fault handler</code> 未能修复错误就通知内核恢复执行出错进程，那错误会再次触发。</p>
<h2 id="reasons-for-thread-faults">Reasons for thread faults</h2>
<blockquote>
<p>When a fault occurs the kernel will pass information describing the cause of the fault as an IPC message.</p>
</blockquote>
<p>内核会在 <code>IPC</code> 消息中一并发送错误原因。</p>
<blockquote>
<ul>
<li>Cap fault: A fault triggered because of an invalid cap access.</li>
<li>VM fault: A fault triggered by incoherent page table state or incorrect memory accesses by a thread.</li>
<li>Unknown Syscall fault: Triggered by performing a syscall invocation that is unknown to the kernel.</li>
<li>Debug fault: Triggered when a breakpoint, watchpoint or single-step debug event occurs.</li>
</ul>
<p>In addition, the following fault types are added by the MCS kernel:</p>
<ul>
<li>Timeout fault: Triggered when a thread consumes all of its budget and still has further execution to do in the current period.</li>
</ul>
</blockquote>
<p>最新版本（2025.3.6）的 <code>seL4</code> 内核可以生成如上几种错误原因。带 <code>MCS</code> 扩展的内核我们先不深入。</p>
<h2 id="thread-fault-messages">Thread fault messages</h2>
<blockquote>
<p>Fault message contains information that tells the fault handler why the fault occured as well as surrounding contextual information about the fault which might help the fault handler to rectify the anomaly.</p>
<p>Each anomaly has its own message format because the information needed to describe each anomaly will be different.</p>
</blockquote>
<p>错误消息中有错误原因和出错位置的上下文信息，帮助 <code>fault handler</code> 更好的修正错误。不同的错误的错误消息有不同的格式，对具体格式的描述要参看 <a href="https://sel4.systems/Info/Docs/seL4-manual-latest.pdf">seL4 Manual</a>。</p>
<h2 id="setting-up-a-fault-endpoint-for-a-thread">Setting up a fault endpoint for a thread</h2>
<blockquote>
<p>When caps are being handed out to the fault endpoint object, one cap to the object must be given to the kernel and one cap to the object must be given to the handler.</p>
</blockquote>
<p>因为错误消息由 <code>kernel</code> 通过 <code>IPC</code> 经 <code>fault endpoint</code> 发送给 <code>fault handler</code>，<code>kernel</code> 为 <code>sender</code>，<code>fault handler</code> 为 <code>receiver</code>，所以 <code>fault endpoint</code> 的 <code>capability</code> 必须交给内核和 <code>fault handler</code> 各一份。</p>
<h3 id="kernel-end-vs-handler-end">Kernel end vs handler end</h3>
<blockquote>
<p>Programmers specify the capability to use a fault handler for a thread when configuring a TCB. As a result the programmer can also set a badge on the kernel’s cap to the fault endpoint object.</p>
</blockquote>
<p>程序员为进程指定 <code>fault handler</code> 的 <code>cpability</code>，同时也应在内核的 <code>fault endpoint capability</code> 上设置与该 <code>handler</code> 对应的标记 <code>badge</code>。</p>
<blockquote>
<p>A badge on the kernel’s cap to a fault endpoint can be used to distinguish fault messages from different faulting threads, such that a single handler can handle faults from multiple threads.</p>
</blockquote>
<p>可根据错误类型的不同在内核的 <code>fault endppint capability</code> 上设置不同的 <code>badge</code>，这样就可以将处理不同错误的函数写到一个 <code>fault handler</code> 进程中，进程根据错误消息的 <code>badge</code> 来判断错误类型即可。</p>
<h3 id="differences-between-mcs-and-master-kernel">Differences between MCS and Master kernel</h3>
<blockquote>
<p>There is a minor difference in the way that the kernel is informed of the cap to a fault endpoint, between the master and MCS kernels.</p>
<p>Regardless though, on both versions of the kernel, to inform the kernel of the fault endpoint for a thread, call the usual <code>seL4_TCB_SetSpace()</code>.</p>
</blockquote>
<p><code>MCS</code> 扩展的内核我们暂不深入。</p>
<h2 id="exercises">Exercises</h2>
<p>在这个 <code>quiz</code> 中，出错进程 <code>faulter</code> 和错误处理进程 <code>handler</code> 共享一个 <code>CSpace</code>。</p>
<h3 id="setting-up-the-endpoint-to-be-used-for-thread-fault-ipc-messages">Setting up the endpoint to be used for thread fault IPC messages.</h3>
<p>首先，<code>faulter</code> 进程通过 <code>IPC</code> 告知 <code>handler</code> 标记过的 <code>fault endpoint capability</code> 在自己 <code>CSpace</code> 中的存储位置：</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/seL4Tutorials/img/fault_handling/faulter告知handler关于cslot位置.JPG" alt="automatic-scalability">
    <figcaption >
        <font size=2>faulter 告知 handler 保存 cslot 的位置</font>
    </figcaption>
</div>
<p>然后，<code>handler</code> 接收消息获知保存位置，标记 <code>fault endpoint capability</code>，并复制到 <code>faulter CSpace</code> 的指定位置：</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/seL4Tutorials/img/fault_handling/handler从faulter接收cslot信息.JPG" alt="automatic-scalability" width=80%>
    <figcaption >
        <font size=2>handler 接收信息并标记、复制 fault endpoint capability</font>
    </figcaption>
</div>
<p>再然后，在 <code>handler</code> 中设置 <code>faulter</code> 的 <code>CSpace</code> 和 <code>VSpace</code>。调用 <code>seL4_CNode_Copy</code> 处理进程时也会将目标进程中 <code>fault endpoint capability</code> 的信息告知内核，本例中就是 <code>foreign_badged_faulter_empty_slot_cap</code>。</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/seL4Tutorials/img/fault_handling/handler为faulter设置CSpace.JPG" alt="automatic-scalability">
    <figcaption >
        <font size=2>handler 为 faulter 设置 CSpace</font>
    </figcaption>
</div>
<p>再然后，<code>handler</code> 回复 <code>faulter</code> 并开始侦听错误消息。<code>seL4_Reply</code> 使用的 <code>ednpoint</code> 为一开始的 <code>sequencing_ep_cap</code>，使 <code>faulter</code> 从 <code>seL4_Call</code> 解除等待消息阻塞继续运行，直到遇到错误。</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/seL4Tutorials/img/fault_handling/handler通知faulter继续运行并等待错误消息.JPG" alt="automatic-scalability" width=80%>
    <figcaption >
        <font size=2>handler 回复 faulter 并等待错误消息</font>
    </figcaption>
</div>
<h3 id="finding-out-information-about-the-generated-thread-fault">Finding out information about the generated thread fault</h3>
<blockquote>
<p>The seL4 manual gives detailed information on which message registers in the IPC buffer contain information about the fault and if you’re so inclined, the libsel4 source code also has the exact code values as well.</p>
</blockquote>
<p><code>kernel</code> 发送给 <code>handler</code> 的错误消息保存在 <code>handler</code> 的 <code>IPC buffer</code> 中，不同类型的错误保存在对应的 <code>MR</code> 中。以 <code>capability fault</code> 为例，<code>seL4</code> 用枚举量定义了不同 <code>capability fault</code> 在 <code>MR</code> 中的 <code>index</code>，本例中遇到的 <code>capability fault</code> 为 <code>seL4_CapFault_Addr</code>：</p>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/seL4Tutorials/img/fault_handling/capfault_message_index_in_mr.JPG" alt="automatic-scalability">
    <figcaption >
        <font size=2>Fault handler 的 IPC buffer 中保存不同类型 capFault 的位置</font>
    </figcaption>
</div>
<div align=center>
	<img src="https://raw.githubusercontent.com/Bouse-W/blog_images/main/BouseBlog/imgs/seL4Tutorials/img/fault_handling/final_result.JPG" alt="automatic-scalability" width=80%>
    <figcaption >
        <font size=2>Final result</font>
    </figcaption>
</div>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#background-what-is-a-fault-and-what-is-a-fault-handler">Background: What is a fault, and what is a fault handler?</a></li>
<li><a href="#thread-faults-vs-other-sources-of-faults">Thread faults vs other sources of faults</a></li>
<li><a href="#how-does-thread-fault-handling-work">How does thread fault handling work?</a></li>
<li><a href="#reasons-for-thread-faults">Reasons for thread faults</a></li>
<li><a href="#thread-fault-messages">Thread fault messages</a></li>
<li><a href="#setting-up-a-fault-endpoint-for-a-thread">Setting up a fault endpoint for a thread</a>
<ul>
<li><a href="#kernel-end-vs-handler-end">Kernel end vs handler end</a></li>
<li><a href="#differences-between-mcs-and-master-kernel">Differences between MCS and Master kernel</a></li>
</ul>
</li>
<li><a href="#exercises">Exercises</a>
<ul>
<li><a href="#setting-up-the-endpoint-to-be-used-for-thread-fault-ipc-messages">Setting up the endpoint to be used for thread fault IPC messages.</a></li>
<li><a href="#finding-out-information-about-the-generated-thread-fault">Finding out information about the generated thread fault</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://bouse-w.github.io/BouseBlog.github.io/post/sel4_capabilities/">
              <h3 class="post-title">
                seL4_Capabilities
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  <p><font size=1>原博客网站 rerevolution.cn（服务器过期了）的重建</font></p>
  <a class="rss" href="https://bouse-w.github.io/BouseBlog.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
